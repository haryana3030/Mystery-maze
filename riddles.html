/**
 * This function handles the OPTIONS preflight request for CORS.
 * It is essential for allowing cross-origin POST requests from your Vercel site.
 */
function doOptions() {
  return ContentService.createTextOutput('')
    .setMimeType(ContentService.MimeType.TEXT)
    .setHeaders({
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type'
    });
}

/**
 * Handles all incoming GET requests (Login, Get Questions, Check Answer, Leaderboard).
 */
function doGet(e) {
  const path = e.parameter.path;

  try {
    switch (path) {
      case "login":
        return sendJSON(handleLogin(e.parameter));
      case "getQuestions":
        return sendJSON(getQuestions());
      case "checkAnswer":
        const qid = e.parameter.qid;
        const answer = e.parameter.answer;
        return sendJSON(checkAnswer(qid, answer));
      case "leaderboard":
        return sendJSON(getLeaderboard());
      default:
        return sendJSON({ success: false, message: "Invalid path" });
    }
  } catch (error) {
    Logger.log(error);
    return sendJSON({ success: false, message: "An error occurred.", error: error.message });
  }
}

/**
 * Handles all incoming POST requests (Saving Final Score).
 */
function doPost(e) {
  const path = e.parameter.path;
  
  try {
    if (path === "saveFinalScore") {
      const data = JSON.parse(e.postData.contents);
      saveFinalScore(data.rollNumber, data.score);
      return sendJSON({ success: true, message: "Final score saved successfully." });
    } else {
      return sendJSON({ success: false, message: "Invalid path or method" });
    }
  } catch (error) {
    Logger.log(error);
    return sendJSON({ success: false, message: "An error occurred.", error: error.message });
  }
}

/**
 * Handles the login logic.
 */
function handleLogin(parameters) {
  const roll = parameters.roll;
  const phone = parameters.phone;
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const userSheet = ss.getSheetByName("users");
  if (!userSheet) {
    return { success: false, message: "User sheet not found." };
  }
  const data = userSheet.getDataRange().getValues();
  
  let found = false;
  for (let i = 1; i < data.length; i++) {
    const sheetRoll = data[i][0];
    const sheetPhone = data[i][1];
    if (sheetRoll.toString() === roll.toString() && sheetPhone.toString() === phone.toString()) {
      found = true;
      break;
    }
  }
  
  return found ? { success: true, message: "Login successful!", rollNumber: roll } : { success: false, message: "Invalid Roll No or Phone." };
}

/**
 * Retrieves all riddles from the "questions" sheet.
 */
function getQuestions() {
  const qSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("questions");
  if (!qSheet) {
    return { success: false, message: "Questions sheet not found." };
  }
  const data = qSheet.getDataRange().getValues();
  const questions = [];

  for (let i = 1; i < data.length; i++) {
    const [qid, question] = data[i]; 
    questions.push({
      qid: qid.toString().trim(),
      question: question.toString().trim()
    });
  }

  return { success: true, questions: questions };
}

/**
 * Checks if a user's answer is correct for a given riddle ID.
 */
function checkAnswer(qid, userAnswer) {
  const qSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("questions");
  if (!qSheet) {
    return { isCorrect: false, message: "Questions sheet not found." };
  }
  const data = qSheet.getDataRange().getValues();

  for (let i = 1; i < data.length; i++) {
    const [sheetQid, , sheetAnswer] = data[i];
    if (sheetQid.toString().trim() === qid.toString().trim()) {
      const isCorrect = userAnswer.toUpperCase().trim() === sheetAnswer.toString().toUpperCase().trim();
      return { isCorrect: isCorrect };
    }
  }

  return { isCorrect: false, message: "Riddle not found." };
}

/**
 * Saves or updates a user's final total score to the "scores" sheet for the leaderboard.
 * NOTE: The sheet must be named "scores" and have columns "Roll No" and "Score".
 */
function saveFinalScore(rollNumber, score) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let scoresSheet = ss.getSheetByName("scores");
  if (!scoresSheet) {
    scoresSheet = ss.insertSheet("scores");
    scoresSheet.appendRow(["Roll No", "Score"]);
  }

  const data = scoresSheet.getDataRange().getValues();
  
  const header = data[0];
  const rollColIndex = header.indexOf("Roll No");
  const scoreColIndex = header.indexOf("Score");

  if (rollColIndex === -1 || scoreColIndex === -1) {
    Logger.log("Required columns 'Roll No' or 'Score' not found in the 'scores' sheet.");
    return;
  }

  let userRow = -1;
  for (let i = 1; i < data.length; i++) {
    if (data[i][rollColIndex] && data[i][rollColIndex].toString().trim() === rollNumber.toString().trim()) {
      userRow = i + 1;
      break;
    }
  }

  if (userRow !== -1) {
    scoresSheet.getRange(userRow, scoreColIndex + 1).setValue(score);
  } else {
    scoresSheet.appendRow([rollNumber, score]);
  }
}

/**
 * Retrieves the current leaderboard from the "scores" sheet.
 */
function getLeaderboard() {
  const scoresSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("scores");
  if (!scoresSheet) {
    return [];
  }

  const data = scoresSheet.getDataRange().getValues();
  if (data.length <= 1) {
    return [];
  }

  const header = data[0];
  const rollColIndex = header.indexOf("Roll No");
  const scoreColIndex = header.indexOf("Score");

  if (rollColIndex === -1 || scoreColIndex === -1) {
    Logger.log("Required columns 'Roll No' or 'Score' not found in the 'scores' sheet.");
    return [];
  }

  let leaderboard = [];
  for (let i = 1; i < data.length; i++) {
    let rollNo = data[i][rollColIndex];
    let totalScore = data[i][scoreColIndex];
    
    if (typeof totalScore === 'number' && !isNaN(totalScore)) {
      leaderboard.push({
        name: rollNo,
        score: totalScore
      });
    }
  }

  return leaderboard;
}

/**
 * Helper function to send a JSON response.
 */
function sendJSON(obj) {
  return ContentService
    .createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}
